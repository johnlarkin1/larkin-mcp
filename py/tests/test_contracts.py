"""Contract validation tests.

These tests ensure the Python implementation stays in sync with the
shared tool-contracts.json and resource.schema.json files.

If these tests fail, it means either:
1. A tool/resource was added to Python but not to the contracts (add it)
2. A tool/resource was removed from Python but still in contracts (remove it)
3. A tool/resource behavior changed and contracts need updating

WARNING: Most of the test suite was generated by AI so just a heads up.
"""

import re

import pytest

from src.constants import MCP_VERSION, RESOURCES_CATEGORIES, RESOURCES_DIR, RESUME_DATE_VERSION
from src.util.resources import list_resources, load_resource, search_resources


class TestToolContractSync:
    """Verify Python tools match tool-contracts.json."""

    # Tools implemented in Python (from tools/registry.py)
    PYTHON_TOOLS = {
        "get_metadata",
        "get_resume",
        "get_bio",
        "get_contact",
        "get_projects",
        "get_skills",
        "get_work",
        "get_available_resources",
        "search_info",
        "health_check",
    }

    def test_all_contract_tools_implemented(self, tool_contracts: dict):
        """Verify all tools in contracts are implemented in Python."""
        contract_tools = set(tool_contracts["tools"].keys())
        missing = contract_tools - self.PYTHON_TOOLS

        assert not missing, f"Tools in contracts but not implemented in Python: {missing}"

    def test_no_extra_tools_in_python(self, tool_contracts: dict):
        """Verify Python doesn't have tools not in contracts."""
        contract_tools = set(tool_contracts["tools"].keys())
        extra = self.PYTHON_TOOLS - contract_tools

        assert not extra, f"Tools in Python but not in contracts: {extra}. Add them to tool-contracts.json"

    def test_tools_match_exactly(self, tool_contracts: dict):
        """Verify exact match between Python tools and contracts."""
        contract_tools = set(tool_contracts["tools"].keys())
        assert self.PYTHON_TOOLS == contract_tools, (
            f"Tool mismatch!\n"
            f"Only in Python: {self.PYTHON_TOOLS - contract_tools}\n"
            f"Only in contracts: {contract_tools - self.PYTHON_TOOLS}"
        )


class TestResourceContractSync:
    """Verify Python resources match tool-contracts.json."""

    # Resources implemented in Python (from resources/registry.py)
    PYTHON_RESOURCES = {
        "config://version",
        "config://resume-version",
        "larkin://resume",
        "larkin://resume.pdf",
        "larkin://bio",
        "larkin://projects",
        "larkin://contact",
        "larkin://skills",
        "larkin://work",
    }

    def test_all_contract_resources_implemented(self, tool_contracts: dict):
        """Verify all resources in contracts are implemented in Python."""
        contract_resources = set(tool_contracts["resources"].keys())
        missing = contract_resources - self.PYTHON_RESOURCES

        assert not missing, f"Resources in contracts but not implemented in Python: {missing}"

    def test_no_extra_resources_in_python(self, tool_contracts: dict):
        """Verify Python doesn't have resources not in contracts."""
        contract_resources = set(tool_contracts["resources"].keys())
        extra = self.PYTHON_RESOURCES - contract_resources

        assert not extra, f"Resources in Python but not in contracts: {extra}. Add them to tool-contracts.json"

    def test_resources_match_exactly(self, tool_contracts: dict):
        """Verify exact match between Python resources and contracts."""
        contract_resources = set(tool_contracts["resources"].keys())
        assert self.PYTHON_RESOURCES == contract_resources, (
            f"Resource mismatch!\n"
            f"Only in Python: {self.PYTHON_RESOURCES - contract_resources}\n"
            f"Only in contracts: {contract_resources - self.PYTHON_RESOURCES}"
        )


class TestResourceCategoriesSync:
    """Verify RESOURCES_CATEGORIES matches schema."""

    def test_categories_match_schema(self, resource_schema: dict):
        """Verify RESOURCES_CATEGORIES matches schema enum."""
        schema_categories = set(resource_schema["properties"]["resourceCategories"]["items"]["enum"])
        python_categories = set(RESOURCES_CATEGORIES)

        assert python_categories == schema_categories, (
            f"Resource categories mismatch!\n"
            f"Only in Python: {python_categories - schema_categories}\n"
            f"Only in schema: {schema_categories - python_categories}"
        )


class TestToolOutputContracts:
    """Verify tool outputs match contract assertions."""

    def test_get_metadata_output(self, tool_contracts: dict):
        """Verify get_metadata output matches contract."""
        from src.types.models import Metadata

        result: Metadata = {
            "mcp_version": MCP_VERSION,
            "mcp_website": "https://johnlarkin1.github.io/2025/larkin-mcp",
            "resume_last_updated": RESUME_DATE_VERSION,
        }

        contract = tool_contracts["tools"]["get_metadata"]["expectedOutput"]

        # Check required fields (TypedDict uses dict access)
        for field in contract["requiredFields"]:
            assert field in result, f"Missing required field: {field}"

        # Check semver pattern
        assert re.match(r"^\d+\.\d+\.\d+$", result["mcp_version"]), "mcp_version should match semver"

        # Check date pattern
        date_pattern = r"^\d{4}-\d{2}-\d{2}$"
        assert re.match(date_pattern, result["resume_last_updated"]), "resume_last_updated should be YYYY-MM-DD"

    def test_get_resume_output(self, tool_contracts: dict):
        """Verify get_resume output matches contract."""
        content = load_resource("resume")

        assert "John Larkin" in content, "Resume should contain 'John Larkin'"
        assert not content.startswith("Resource '"), "Should not be an error message"

    def test_get_available_resources_output(self, tool_contracts: dict):
        """Verify get_available_resources output matches contract."""
        resources = list_resources()
        contract = tool_contracts["tools"]["get_available_resources"]["expectedOutput"]

        # Check it contains expected resources
        for assertion in contract["assertions"]:
            if assertion.startswith("Contains '"):
                expected = assertion.split("'")[1]
                assert expected in resources, f"Missing expected resource: {expected}"

        # Check all items are strings
        for item in resources:
            assert isinstance(item, str), f"Resource should be string, got {type(item)}"

    def test_search_info_with_matches(self, tool_contracts: dict):
        """Verify search_info with matches returns expected format."""
        results = search_resources("Python")

        if results:
            output = []
            for resource, lines in results.items():
                output.append(f"## {resource.title()}")
                output.extend(f"  - {line.strip()}" for line in lines[:5])

            formatted = "\n".join(output)
            assert "##" in formatted, "Should contain ## headers when matches found"

    def test_search_info_no_matches(self, tool_contracts: dict):
        """Verify search_info with no matches returns expected message."""
        results = search_resources("xyznonexistent123")
        assert len(results) == 0, "Should find no matches for nonsense query"

        # Verify the formatted message
        message = "No matches found for 'xyznonexistent123'"
        assert "No matches found" in message

    def test_health_check_output(self, tool_contracts: dict, resource_schema: dict):
        """Verify health_check output matches contract and schema."""
        from src.types.models import HealthCheckResponse, ResourceStatus

        resources_status = {}
        for resource in RESOURCES_CATEGORIES:
            content = load_resource(resource)
            is_available = not content.startswith("Resource '") and not content.startswith("Error")
            resources_status[resource] = ResourceStatus(
                available=is_available,
                size_bytes=len(content.encode()) if is_available else 0,
            )

        result = HealthCheckResponse(
            status="healthy",
            version=MCP_VERSION,
            resources=resources_status,
        )

        # Check required fields from contract
        contract = tool_contracts["tools"]["health_check"]["expectedOutput"]
        for field in contract["requiredFields"]:
            assert hasattr(result, field), f"Missing required field: {field}"

        # Check status enum from schema
        schema_statuses = resource_schema["definitions"]["healthCheck"]["properties"]["status"]["enum"]
        assert result.status in schema_statuses, f"Invalid status: {result.status}"

        # Check version matches semver
        assert re.match(r"^\d+\.\d+\.\d+$", result.version), "version should match semver"

        # Check each resource has required fields
        for name, status in result.resources.items():
            assert isinstance(status.available, bool), f"{name}.available should be bool"
            assert isinstance(status.size_bytes, int), f"{name}.size_bytes should be int"
            assert status.size_bytes >= 0, f"{name}.size_bytes should be >= 0"


class TestResourceOutputContracts:
    """Verify MCP resource outputs match contract assertions."""

    def test_config_version_resource(self, tool_contracts: dict):
        """Verify config://version matches semver pattern."""
        # This is what the resource returns
        version = MCP_VERSION
        assert re.match(r"^\d+\.\d+\.\d+$", version), "Should match semver pattern"

    def test_config_resume_version_resource(self, tool_contracts: dict):
        """Verify config://resume-version matches date pattern."""
        date = RESUME_DATE_VERSION
        assert re.match(r"^\d{4}-\d{2}-\d{2}$", date), "Should match YYYY-MM-DD pattern"

    def test_larkin_resume_resource(self, tool_contracts: dict):
        """Verify larkin://resume returns expected content."""
        content = load_resource("resume")
        assert content, "Should return non-empty string"
        assert "John Larkin" in content, "Should contain 'John Larkin'"

    def test_larkin_resume_pdf_resource(self, tool_contracts: dict):
        """Verify larkin://resume.pdf returns valid PDF."""
        pdf_path = RESOURCES_DIR / "resume" / "larkin_resume.pdf"
        if pdf_path.exists():
            content = pdf_path.read_bytes()
            assert content.startswith(b"%PDF"), "Should start with PDF magic bytes"
        else:
            pytest.skip("PDF file not found")

    def test_larkin_bio_resource(self, tool_contracts: dict):
        """Verify larkin://bio returns non-empty content."""
        content = load_resource("bio")
        assert content, "Should return non-empty string"
        assert not content.startswith("Resource '"), "Should not be error"

    def test_larkin_projects_resource(self, tool_contracts: dict):
        """Verify larkin://projects returns non-empty content."""
        content = load_resource("projects")
        assert content, "Should return non-empty string"
        assert not content.startswith("Resource '"), "Should not be error"

    def test_larkin_contact_resource(self, tool_contracts: dict):
        """Verify larkin://contact returns non-empty content."""
        content = load_resource("contact")
        assert content, "Should return non-empty string"
        assert not content.startswith("Resource '"), "Should not be error"

    def test_larkin_skills_resource(self, tool_contracts: dict):
        """Verify larkin://skills returns non-empty content."""
        content = load_resource("skills")
        assert content, "Should return non-empty string"
        assert not content.startswith("Resource '"), "Should not be error"

    def test_larkin_work_resource(self, tool_contracts: dict):
        """Verify larkin://work returns non-empty content."""
        content = load_resource("work")
        assert content, "Should return non-empty string"
        assert not content.startswith("Resource '"), "Should not be error"
